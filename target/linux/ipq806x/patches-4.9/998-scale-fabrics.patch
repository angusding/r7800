From 7f4d9b5c8814329a66fe44d0dac55a4bd3cbcb78 Mon Sep 17 00:00:00 2001
From: Rajith Cherian <rajith@codeaurora.org>
Date: Wed, 16 Sep 2015 19:33:22 +0530
Subject: ipq806x: fabrics: Support DDR and APPS FABRIC scaling

Implemented DDR and APPS FABRIC scaling framework.
Sub systems which requires these FABRICS to be scaled
should register with the clock and idle frequency of that
particular clock. When all the registered clocks are at
idle frequencies, DDR and APPS FABRICs will operate at
nominal level or else it operates at high.

Signed-off-by: Rajith Cherian <rajith@codeaurora.org>
(cherry picked from commit 778276c610e331f87ee2c16aa2fe746504c1233c)

Change-Id: I85b06da47fe3b9e6114fc20924098a14faab9dca
Signed-off-by: Abhishek Sahu <absahu@codeaurora.org>
---
 .../devicetree/bindings/clock/qcom,fab-scaling.txt |  19 ++
 drivers/clk/qcom/Makefile                          |   1 +
 drivers/clk/qcom/fab_scaling.c                     | 200 +++++++++++++++++++++
 drivers/cpufreq/cpufreq-dt.c                    |  17 ++
 include/linux/fab_scaling.h                        |  54 ++++++
 6 files changed, 301 insertions(+)
 create mode 100644 Documentation/devicetree/bindings/clock/qcom,fab-scaling.txt
 create mode 100644 drivers/clk/qcom/fab_scaling.c
 create mode 100644 include/linux/fab_scaling.h

diff --git a/Documentation/devicetree/bindings/clock/qcom,fab-scaling.txt b/Documentation/devicetree/bindings/clock/qcom,fab-scaling.txt
new file mode 100644
index 0000000..f355b3e
--- /dev/null
+++ b/Documentation/devicetree/bindings/clock/qcom,fab-scaling.txt
@@ -0,0 +1,19 @@
+Qualcomm Atheros DDR and APPS FABRICS scaling
+------------------------------------------------
+
+Required properties :
+- compatible : "qcom,fab-scaling"
+- clocks : defines each clock needed
+- clock-names : contains clock names
+- fab_freq_high : Turbo FABRIC frequency
+- fab_freq_nominal : Nominal FABRIC frequency
+
+Example:
+
+fab-scaling {
+	compatible = "qcom,fab-scaling";
+	clocks = <&apps_fabric_clk>, <&ebi1_clk>;
+	clock-names = "apps-fab-clk", "ddr-fab-clk";
+	fab_freq_high = <533000000>;
+	fab_freq_nominal = <400000000>;
+};
diff --git a/drivers/clk/qcom/Makefile b/drivers/clk/qcom/Makefile
index 3378df3..e1bed2d 100644
--- a/drivers/clk/qcom/Makefile
+++ b/drivers/clk/qcom/Makefile
@@ -13,6 +13,7 @@ clk-qcom-y += clk-regmap-mux.o
 clk-qcom-$(CONFIG_KRAIT_CLOCKS) += clk-krait.o
 clk-qcom-y += clk-hfpll.o
 clk-qcom-y += reset.o
+clk-qcom-y += fab_scaling.o
 clk-qcom-$(CONFIG_QCOM_GDSC) += gdsc.o
 
 obj-$(CONFIG_APQ_GCC_8084) += gcc-apq8084.o
diff --git a/drivers/clk/qcom/fab_scaling.c b/drivers/clk/qcom/fab_scaling.c
new file mode 100644
index 0000000..5ebe3db
--- /dev/null
+++ b/drivers/clk/qcom/fab_scaling.c
@@ -0,0 +1,200 @@
+/*
+ * Copyright (c) 2015, The Linux Foundation. All rights reserved.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/err.h>
+#include <linux/io.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/clk.h>
+#include <linux/clk-provider.h>
+#include <linux/fab_scaling.h>
+
+#define MAX_CLK_COUNT	5
+
+#define APPS_FAB_CLK	"apps-fab-clk"
+#define DDR_FAB_CLK	"ddr-fab-clk"
+
+static u32 fab_freq_high;
+static u32 fab_freq_nominal;
+
+static struct clk *apps_fab_clk;
+static struct clk *ddr_fab_clk;
+
+static struct fab_scaling_info arr_monitor_clk[MAX_CLK_COUNT];
+
+int scale_fabrics(void)
+{
+	int i, clk_cnt = 0, scale_down = 1;
+	unsigned long curr_freq, new_freq;
+
+	if (!apps_fab_clk || !ddr_fab_clk)
+		return -1;
+
+	for (i = 0; i < MAX_CLK_COUNT; i++) {
+		if (!arr_monitor_clk[i].cpu_clk || !arr_monitor_clk[i].idle_freq)
+			continue;
+
+		clk_cnt++;
+		curr_freq = clk_get_rate(arr_monitor_clk[i].cpu_clk);
+		if (curr_freq > arr_monitor_clk[i].idle_freq) {
+			scale_down = 0;
+			break;
+		}
+	}
+
+	if (clk_cnt) {
+		if (scale_down)
+			new_freq = fab_freq_nominal;
+		else
+			new_freq = fab_freq_high;
+
+		clk_set_rate(apps_fab_clk, new_freq);
+		clk_set_rate(ddr_fab_clk, new_freq);
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(scale_fabrics);
+
+int fab_scaling_register(struct fab_scaling_info *data)
+{
+	int i, ret = -1;
+
+	if (!data)
+		return ret;
+
+	if (!data->cpu_clk)
+		return ret;
+
+	for (i = 0; i < MAX_CLK_COUNT; i++) {
+		if (arr_monitor_clk[i].cpu_clk == data->cpu_clk) {
+			pr_err("Clk already registered!!!\n");
+			return -1;
+		}
+	}
+
+	for (i = 0; i < MAX_CLK_COUNT; i++) {
+		if (!arr_monitor_clk[i].clk) {
+			arr_monitor_clk[i].cpu_clk = data->cpu_clk;
+			arr_monitor_clk[i].idle_freq = data->idle_freq;
+			ret = 0;
+			break;
+		}
+	}
+
+	if (ret)
+		pr_err("FABRIC scaling registration failed.\n");
+
+	return ret;
+}
+EXPORT_SYMBOL(fab_scaling_register);
+
+int fab_scaling_unregister(struct clk *cpu_clk)
+{
+	int i;
+
+	if (!clk)
+		return -1;
+
+	for (i = 0; i < MAX_CLK_COUNT; i++) {
+		if (arr_monitor_clk[i].cpu_clk == clk) {
+			arr_monitor_clk[i].cpu_clk = 0;
+			arr_monitor_clk[i].idle_freq = 0;
+			break;
+		}
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(fab_scaling_unregister);
+
+
+static int ipq806x_fab_scaling_probe(struct platform_device *pdev)
+{
+	struct device_node *np = pdev->dev.of_node;
+
+	if (!np)
+		return -ENODEV;
+
+	if (of_property_read_u32(np, "fab_freq_high", &fab_freq_high)) {
+		pr_err("FABRICS turbo freq not found. Using defaults...\n");
+		fab_freq_high = 533000000;
+	}
+
+	if (of_property_read_u32(np, "fab_freq_nominal", &fab_freq_nominal)) {
+		pr_err("FABRICS nominal freq not found. Using defaults...\n");
+		fab_freq_nominal = 400000000;
+	}
+
+	apps_fab_clk = devm_clk_get(&pdev->dev, APPS_FAB_CLK);
+	if (IS_ERR(apps_fab_clk)) {
+		pr_err("Failed to get APPS FABRIC clock\n");
+		apps_fab_clk = 0;
+		return -ENODEV;
+	}
+
+	ddr_fab_clk = devm_clk_get(&pdev->dev, DDR_FAB_CLK);
+	if (IS_ERR(ddr_fab_clk)) {
+		pr_err("Failed to get DDR FABRIC clock\n");
+		ddr_fab_clk = 0;
+		return -ENODEV;
+	}
+
+	return 0;
+}
+
+static int ipq806x_fab_scaling_remove(struct platform_device *pdev)
+{
+	int i;
+
+	for (i = 0; i < MAX_CLK_COUNT; i++) {
+		arr_monitor_clk[i].cpu_clk = 0;
+		arr_monitor_clk[i].idle_freq = 0;
+	}
+
+	return 0;
+}
+
+static const struct of_device_id fab_scaling_ipq806x_match_table[] = {
+	{ .compatible = "qcom,fab-scaling" },
+	{ }
+};
+
+static struct platform_driver fab_scaling_ipq806x_driver = {
+	.probe		= ipq806x_fab_scaling_probe,
+	.remove		= ipq806x_fab_scaling_remove,
+	.driver		= {
+		.name   = "fab-scaling",
+		.owner  = THIS_MODULE,
+		.of_match_table = fab_scaling_ipq806x_match_table,
+	},
+};
+
+static int __init fab_scaling_ipq806x_init(void)
+{
+	return platform_driver_register(&fab_scaling_ipq806x_driver);
+}
+late_initcall(fab_scaling_ipq806x_init);
+
+static void __exit fab_scaling_ipq806x_exit(void)
+{
+	platform_driver_unregister(&fab_scaling_ipq806x_driver);
+}
+module_exit(fab_scaling_ipq806x_exit);
diff --git a/drivers/cpufreq/cpufreq-dt.c b/drivers/cpufreq/cpufreq-dt.c
index ab09b23..c71fa5f 100644
--- a/drivers/cpufreq/cpufreq-dt.c
+++ b/drivers/cpufreq/cpufreq-dt.c
@@ -24,6 +24,7 @@
 #include <linux/regulator/consumer.h>
 #include <linux/slab.h>
 #include <linux/thermal.h>
+#include <linux/fab_scaling.h>
 
 #include "cpufreq-dt.h"
 
@@ -84,6 +85,8 @@ static int set_target(struct cpufreq_policy *policy, unsigned int index)
 	}
 
 	mutex_unlock(&priv->lock);
+	
+	scale_fabrics();
 
 	return ret;
 }
@@ -231,6 +234,7 @@ static int cpufreq_init(struct cpufreq_policy *policy)
 	struct srcu_notifier_head *opp_srcu_head;
 	struct device_node *l2_np;
 	struct clk *l2_clk = NULL;
+	struct fab_scaling_info fab_data;
 
 	cpu_dev = get_cpu_device(policy->cpu);
 	if (!cpu_dev) {
@@ -349,6 +353,12 @@ static int cpufreq_init(struct cpufreq_policy *policy)
 	policy->driver_data = priv;
 	policy->clk = cpu_clk;
 
+	if (!of_property_read_u32(np, "cpu_fab_threshold",
+					&fab_data.idle_freq)) {
+		fab_data.clk = clk;
+		fab_scaling_register(&fab_data);
+	}
+
 	rcu_read_lock();
 	suspend_opp = dev_pm_opp_get_suspend_opp(cpu_dev);
 	if (suspend_opp)
@@ -493,6 +503,15 @@ static int dt_cpufreq_probe(struct platform_device *pdev)
 
 static int dt_cpufreq_remove(struct platform_device *pdev)
 {
+	struct clk *cpu_clk;
+	struct device *cpu_dev;
+	struct cpufreq_policy *policy;
+
+	cpu_dev = get_cpu_device(policy->cpu);
+
+	cpu_clk = clk_get(cpu_dev, NULL);
+	fab_scaling_unregister(cpu_clk);
+
 	cpufreq_unregister_driver(&dt_cpufreq_driver);
 	return 0;
 }
diff --git a/include/linux/fab_scaling.h b/include/linux/fab_scaling.h
new file mode 100644
index 0000000..1dc99f5
--- /dev/null
+++ b/include/linux/fab_scaling.h
@@ -0,0 +1,54 @@
+/*
+ * Copyright (c) 2015, The Linux Foundation. All rights reserved.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+
+#ifndef __FAB_SCALING_H
+#define __FAB_SCALING_H
+
+struct fab_scaling_info {
+	struct clk *cpu_clk;
+	unsigned long idle_freq;
+};
+
+/**
+ * fab_scaling_register - Register for APPS and DDR FABRICS scaling
+ * @data: FABRIC scaling info
+ *
+ * This registers the clock source which needs to be monitored.
+ *
+ */
+int fab_scaling_register(struct fab_scaling_info *data);
+
+/**
+ * scale_fabrics - Scale DDR and APPS FABRICS
+ *
+ * This function monitors all the registered clocks and does APPS
+ * and DDR FABRIC scaling based on the idle frequencies with which
+ * it was registered.
+ *
+ */
+int scale_fabrics(void);
+
+/**
+ * fab_scaling_unregister - Unregister for APPS and DDR FABRICS scaling
+ * @clk: Clock pointer which needs to be unregistered.
+ *
+ * This unregisters the clock source and is no longer monitored.
+ *
+ */
+int fab_scaling_unregister(struct clk *clk);
+
+#endif
-- 
cgit v1.1
